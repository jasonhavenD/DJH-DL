# [machine learning crash course](https://developers.google.com/machine-learning/crash-course)

[TOC]

## Introduction to Machine Learning

- 机器学习系统通过学习如何组合输入信息来对从未见过的数据做出有用的预测。

- **标签**是我们要预测的事物，即简单线性回归中的 `y` 变量

- **特征**是输入变量，即简单线性回归中的 `x` 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征，按如下方式指定：

  {x1,x2,...xN}

  在垃圾邮件检测器示例中，特征可能包括：

  - 电子邮件文本中的字词
  - 发件人的地址
  - 发送电子邮件的时段
  - 电子邮件中包含“一种奇怪的把戏”这样的短语。

- **样本**是指数据的特定实例：**x**。（我们采用粗体 **x** 表示它是一个矢量。）我们将样本分为以下两类：

  - 有标签样本 **有标签样本**同时包含特征和标签
  - 无标签样本 **无标签样本**包含特征，但不包含标签

- 模型定义了特征与标签之间的关系。

  - **训练**表示创建或**学习**模型。也就是说，您向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。
  - **推断**表示将训练后的模型应用于无标签样本。也就是说，您使用训练后的模型来做出有用的预测 (`y'`)。例如，在推断期间，您可以针对新的无标签样本预测 `medianHouseValue`。

- **回归**模型可预测连续值。例如，回归模型做出的预测可回答如下问题：

  - 加利福尼亚州一栋房产的价值是多少？
  - 用户点击此广告的概率是多少？

- **分类**模型可预测离散值。例如，分类模型做出的预测可回答如下问题：

  - 某个指定电子邮件是垃圾邮件还是非垃圾邮件？
  - 这是一张狗、猫还是仓鼠图片？

## Descending into ML

- **线性回归**是一种找到最适合一组点的直线或超平面的方法

  ![线性回归](././tensorflow/image/线性回归.png)

- 事实上，虽然该直线并未精确无误地经过每个点，但针对我们拥有的数据，清楚地显示了鸣叫声与温度之间的关系。只需运用一点代数知识，您就可以将这种关系写下来，如下所示：

  y=mx+b

  其中：

  - y 指的是温度（以摄氏度表示），即我们试图预测的值。
  - m 指的是直线的斜率。
  - x 指的是每分钟的鸣叫声次数，即输入特征的值。
  - b 指的是 y 轴截距。

  按照机器学习的惯例，您需要写一个存在细微差别的模型方程式：

  y′=b+w1x1

  其中：

  - y′ 指的是预测[标签](https://developers.google.com/machine-learning/crash-course/framing/ml-terminology#labels)（理想输出值）。
  - b 指的是偏差（y 轴截距）。而在一些机器学习文档中，它称为 w0。
  - w1 指的是特征 1 的权重。权重与上文中用 m 表示的“斜率”的概念相同。
  - x1 指的是[特征](https://developers.google.com/machine-learning/crash-course/framing/ml-terminology#features)（已知输入项）。

  要根据新的每分钟的鸣叫声值 x1 **推断**（预测）温度 y′，只需将 x1 值代入此模型即可。

- 简单来说，**训练**模型表示通过有标签样本来学习（确定）所有权重和偏差的理想值。在监督式学习中，机器学习算法通过以下方式构建模型：检查多个样本并尝试找出可最大限度地减少损失的模型；这一过程称为**经验风险最小化**。

- 损失是对糟糕预测的惩罚。也就是说，**损失**是一个数值，表示对于单个样本而言模型预测的准确程度。如果模型的预测完全准确，则损失为零，否则损失会较大。训练模型的目标是从所有样本中找到一组平均损失“较小”的权重和偏差。

- **平方损失**：一种常见的损失函数

  - 线性回归模型使用的是一种称为**平方损失**（又称为 **L2 损失**）的损失函数

  - ```
    = the square of the difference between the label and the prediction
    = (observation - prediction(x))2
    = (y - y')2
    ```

- **均方误差** (**MSE**) 指的是每个样本的平均平方损失。要计算 MSE，请求出各个样本的所有平方损失之和，然后除以样本数量：
  $$
  MSE = \frac{1}{N} \sum_{(x,y)\in D} (y - prediction(x))^2
  $$

  > 其中：
  >
  > - (x,y)指的是样本，其中
  >   - x 指的是模型进行预测时使用的特征集（例如，温度、年龄和交配成功率）。
  >   - y 指的是样本的标签（例如，每分钟的鸣叫次数）。
  > - prediction(x) 指的是权重和偏差与特征集 x 结合的函数。
  > - D 指的是包含多个有标签样本（即 (x,y)）的数据集。
  > - N 指的是 D 中的样本数量。

## Reducing Loss

- 对于我们一直在研究的回归问题，所产生的损失与 w1 的图形始终是凸形。换言之，图形始终是碗状图

![梯度下降](./tensorflow/image/梯度下降.png)

- 凸形问题只有一个最低点；即只存在一个斜率正好为 0 的位置。这个最小值就是损失函数收敛之处。

- 梯度下降法的第一个阶段是为 w1 选择一个起始值（起点）。起点并不重要；因此很多算法就直接将 w1 设为 0 或随机选择一个值。

- 然后，梯度下降法算法会计算损失曲线在起点处的梯度。简而言之，**梯度**是偏导数的矢量；它可以让您了解哪个方向距离目标“更近”或“更远”。请注意，损失相对于单个权重的梯度（如图 3 所示）就等于导数。

- 梯度是一个矢量，梯度始终指向损失函数中**增长**最为迅猛的方向。梯度下降法算法会沿着**负梯度**的方向走一步，以便尽快降低损失。**梯度下降法依赖于负梯度**，然后，梯度下降法会重复此过程，逐渐接近最低点。

- ​

  ![](./tensorflow/image/负梯度下降.png)

- 梯度下降法算法用梯度乘以一个称为**学习速率**（有时也称为**步长**）的标量，以确定下一个点的位置。例如，如果梯度大小为 2.5，学习速率为 0.01，则梯度下降法算法会选择距离前一个点 0.025 的位置作为下一个点。

- **超参数**是编程人员在机器学习算法中用于调整的旋钮。大多数机器学习编程人员会花费相当多的时间来调整学习速率。如果您选择的学习速率过小，就会花费太长的学习时间；相反，如果您指定的学习速率过大，下一个点将永远在 U 形曲线的底部随意弹跳，就好像量子力学实验出现了严重错误一样。

- 每个回归问题都存在一个[Goldilocks_principle](https://wikipedia.org/wiki/Goldilocks_principle)学习速率，理想的学习速率：

- > 一维空间中的理想学习速率是 1f(x)″（f(x) 对 x 的二阶导数的倒数）。
  >
  > 二维或多维空间中的理想学习速率是[海森矩阵](https://wikipedia.org/wiki/Hessian_matrix)（由二阶偏导数组成的矩阵）的倒数。
  >
  > 广义凸函数的情况则更为复杂。

- SGD 随机梯度下降。在梯度下降法中，**批量**指的是用于在**单次迭代**中计算梯度的样本总数。实际上，批量大小越大，出现冗余的可能性就越高。 如果我们可以通过更少的计算量得出正确的平均梯度，会怎么样？通过从我们的数据集中随机选择样本，我们可以通过小得多的数据集估算（尽管过程非常杂乱）出较大的平均值。 **随机梯度下降法** (**SGD**) 将这种想法运用到极致，它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱。“随机”这一术语表示构成各个批量的一个样本都是随机选择的。**小批量随机梯度下降法**（**小批量 SGD**）是介于全批量迭代与 SGD 之间的折衷方案。小批量通常包含 10-1000 个随机选择的样本。小批量 SGD 可以减少 SGD 中的杂乱样本数量，但仍然比全批量更高效。

  ## Generalization

- 过拟合模型在训练过程中产生的损失很低，但在预测新数据方面的表现却非常糟糕;过拟合是由于模型的复杂程度超出所需程度而造成的，机器学习的基本冲突是适当拟合我们的数据，但也要尽可能简单地拟合数据。

- 机器学习的目标是对从真实概率分布（已隐藏）中抽取的新数据做出良好预测。遗憾的是，模型无法查看整体情况；模型只能从训练数据集中取样。

- 奥卡姆剃刀定律在机器学习方面的运用如下：

  > 机器学习模型越简单，良好的实证结果就越有可能不仅仅基于样本的特性。

- 以下三项基本假设阐明了泛化：

  - 我们从分布中随机抽取**独立同分布** (**i.i.d**) 的样本。换言之，样本之间不会互相影响。（另一种解释：i.i.d. 是表示变量随机性的一种方式）。
  - 分布是**平稳的**；即分布在数据集内不会发生变化。
  - 我们从**同一分布**的数据划分中抽取样本。

- 总结

  - 如果某个模型尝试紧密拟合训练数据，但却不能很好地泛化到新数据，就会发生过拟合。
  - 如果不符合监督式机器学习的关键假设，那么我们将失去对新数据进行预测这项能力的重要理论保证。
  - **请勿对测试数据进行训练。**

## Validation

![validation.png](./tensorflow/image/validation.png)

- 在这一经过改进的工作流程中：

  1. 选择在验证集上获得最佳效果的模型。
  2. 使用测试集再次检查该模型。

  该工作流程之所以更好，原因在于它暴露给测试集的信息更少。

> 提示
>
> 不断使用测试集和验证集会使其逐渐失去效果。也就是说，您使用相同数据来决定超参数设置或其他模型改进的次数越多，您对于这些结果能够真正泛化到未见过的新数据的信心就越低。请注意，验证集的失效速度通常比测试集缓慢。
>
> 如果可能的话，建议您收集更多数据来“刷新”测试集和验证集。重新开始是一种很好的重置方式。

## Representation

- 将原始数据映射到特征

  - **特征工程** 指的是将原始数据转换为特征矢量。进行特征工程预计需要大量时间。

  - 映射数值

    - 机器学习模型根据浮点值进行训练，因此整数和浮点原始数据不需要特殊编码

  - 映射字符串值

    - 模型无法通过字符串值学习规律，因此您需要进行一些特征工程来将这些值转换为数字形式

    > 1. 首先，为您要表示的所有特征的字符串值定义一个**词汇表**。对于 `street_name` 特征，该词汇表中将包含您知道的所有街道。
    >
    >    **注意**：所有其他街道都可以归入一个笼统的“其他”类别，该类别称为 **OOV**（未收录到词汇表中）桶。
    >
    > 2. 然后，使用该词汇表创建一个**独热编码**，用于将指定字符串值表示为二元矢量。在该矢量（与指定的字符串值对应）中：
    >
    >    - 只有一个元素设为 `1`。
    >    - 其他所有元素均设为 `0`。
    >
    >    该矢量的长度等于词汇表中的元素数。

  - 映射分类（枚举）值 : 分类特征具有一组离散的可能值

- 良好特征的特点

  - 避免很少使用的离散特征值:良好的特征值应该在数据集中出现大约 5 次以上。这样一来，模型就可以学习该特征值与标签是如何关联的。
  - 最好具有清晰明确的含义:每个特征对于项目中的任何人来说都应该具有清晰明确的含义。
  - 不要将“神奇”的值与实际数据混为一谈:良好的浮点特征不包含超出范围的异常断点或“神奇”的值
  - 考虑上游不稳定性: 特征的定义不应随时间发生变化。

- 清理数据

  - 缩放特征值

    > - **缩放**是指将浮点特征值从自然范围（例如 100 到 900）转换为标准范围（例如 0 到 1 或 -1 到 +1）。如果某个特征集只包含一个特征，则缩放可以提供的实际好处微乎其微或根本没有。不过，如果特征集包含多个特征，则缩放特征可以带来以下优势：
    >   - 帮助梯度下降法更快速地收敛。
    >   - 帮助避免“NaN 陷阱”。在这种陷阱中，模型中的一个数值变成 [NaN](https://wikipedia.org/wiki/NaN)（例如，当某个值在训练期间超出浮点精确率限制时），并且模型中的所有其他数值最终也会因数学运算而变成 NaN。
    >   - 帮助模型为每个特征确定合适的权重。如果没有进行特征缩放，则模型会对范围较大的特征投入过多精力。

  - 不需要对每个浮点特征进行完全相同的缩放。即使特征 A 的范围是 -1 到 +1，同时特征 B 的范围是 -3 到 +3，也不会产生什么恶劣的影响。不过，如果特征 B 的范围是 5000 到 100000，您的模型会出现糟糕的响应。

  - 缩放常见方法

    > 要缩放数字数据，一种显而易见的方法是将 [最小值，最大值] 以线性方式映射到较小的范围，例如 [-1，+1]。
    >
    > 另一种热门的缩放策略是计算每个值的 Z 得分。Z 得分与距离均值的标准偏差数相关。换而言之：
    >
    > scaledvalue=(value−mean)/stddev.
    >
    > 例如，给定以下条件：
    >
    > - 均值 = 100
    > - 标准偏差 = 20
    > - 原始值 = 130
    >
    > 则：
    >
    > ```
    >   scaled_value = (130 - 100) / 20
    >   scaled_value = 1.5
    >
    > ```
    >
    > 使用 Z 得分进行缩放意味着，大多数缩放后的值将介于 -3 和 +3 之间，而少量值将略高于或低于该范围。

  - 处理极端离群值

    - [离群值](https://baike.baidu.com/item/%E7%A6%BB%E7%BE%A4%E5%80%BC/311974?fr=aladdin) : 离群值(outlier)，也称逸出值，是指在数据中有一个或几个数值与其他[数值](https://baike.baidu.com/item/%E6%95%B0%E5%80%BC/2013853)相比差异较大。

    - 如何最大限度降低这些极端离群值的影响？

      > 一种方法是对每个值取对数

  - 分箱

    - 分箱边界

      > 为了简单起见，我们在纬度样本中使用整数作为分箱边界。如果我们需要更精细的解决方案，我们可以每隔 1/10 个纬度拆分一次分箱边界。添加更多箱可让模型从纬度 37.4 处学习和维度 37.5 处不一样的行为，但前提是每 1/10 个纬度均有充足的样本可供学习。
      >
      > 另一种方法是按[分位数](https://wikipedia.org/wiki/Quantile)分箱，这种方法可以确保每个桶内的样本数量是相等的。按分位数分箱完全无需担心离群值。

  - 清查

    > 在现实生活中，数据集中的很多样本是不可靠的，原因有以下一种或多种：
    >
    > - **遗漏值。** 例如，有人忘记为某个房屋的年龄输入值。
    > - **重复样本。** 例如，服务器错误地将同一条记录上传了两次。
    > - **不良标签。** 例如，有人错误地将一颗橡树的图片标记为枫树。
    > - **不良特征值。** 例如，有人输入了多余的位数，或者温度计被遗落在太阳底下。
    >
    > 一旦检测到存在这些问题，您通常需要将相应样本从数据集中移除，从而“修正”不良样本。
    >
    > - 要检测遗漏值或重复样本，您可以编写一个简单的程序。
    > - 检测不良特征值或标签可能会比较棘手

    ​

  - 了解数据

    > - 遵循以下规则：
    >
    >   - 记住您预期的数据状态。
    >   - 确认数据是否满足这些预期（或者您可以解释为何数据不满足预期）。
    >   - 仔细检查训练数据是否与其他来源（例如信息中心）的数据一致。
    >
    >   像处理任何任务关键型代码一样谨慎处理您的数据。良好的机器学习依赖于良好的数据。

## Feature Crosses

- **特征组合**是指两个或多个特征相乘形成的**合成特征**。特征的相乘组合可以提供超出这些特征单独能够提供的预测能力。

- 一般讲利用其他特征乘积创建的合成特征的过程称为特征交叉、特征交叉乘积

- 特征组合

  - 定义 `[A x B]` 形式的模板
  - 可以比较复杂：`[A x B x C x D x E]`
  - 当 `A` 和 `B` 表示布尔特征（例如分箱）时，所得到的组合可能会极其稀疏

- 使用特征组合 + 大量数据是学习高度复杂模型的一种有效策略

- 线性问题可以用一个直线进行划分、但是非线性问题一条直线无法分开，这时候可以创建一个特征组合。**特征组合**是指通过将两个或多个输入特征相乘来对特征空间中的非线性规律进行编码的合成特征。“cross”（组合）这一术语来自 **[cross product](https://wikipedia.org/wiki/Cross_product)**（向量积）。我们通过将 x1 与 x2 组合来创建一个名为 x3 的特征组合：
  $$
  x_3 = x_1x_2
  $$

- 像处理任何其他特征一样来处理这个新建的 x3 特征组合。线性公式变为：

- $$
  y = b + w_1x_1 + w_2x_2 + w_3x_3
  $$

- 线性算法可以算出 w3 的权重，就像算出 w1 和 w2 的权重一样。换言之，虽然 w3 表示非线性信息，但您不需要改变线性模型的训练方式来确定 w3 的值。

- 特征组合的种类

  > 我们可以创建很多不同种类的特征组合。例如：
  >
  > - `[A X B]`：将两个特征的值相乘形成的特征组合。
  > - `[A x B x C x D x E]`：将五个特征的值相乘形成的特征组合。
  > - `[A x A]`：对单个特征的值求平方形成的特征组合。
  >
  > 通过采用[随机梯度下降法](https://developers.google.com/machine-learning/crash-course/reducing-loss/stochastic-gradient-descent)，可以有效地训练线性模型。因此，在使用扩展的线性模型时辅以特征组合一直都是训练大规模数据集的有效方法。

## Regularization for Simplicity

- 正则化避免过拟合

- 降低模型的复杂度

  - 我们希望尽可能降低模型的复杂度。

  - 我们可以将这种想法纳入训练时所进行的优化中。

  - 结构风险最小化：

    - 旨在减少训练误差

    - 同时平衡复杂度

    - $$
      \text{minimize: } Loss(Data\;|\;Model) + complexity(Model)
      $$

  - 如何定义模型复杂度？

  - 首选较小的权重

  - 可以通过 L2 **正则化**（也称为岭正则化）对这种想法进行编码

  - - *复杂度（模型）= 权重的平方和*
    - 减少非常大的权重
    - 对于线性模型：首选比较平缓的斜率
    - 贝叶斯先验概率：
    - - 权重应该以 0 为中心
      - 权重应该呈正态分布

- L2 正则化的损失函数，第二项是正则项，降低模型复杂度，避免过拟合

> $$
> L(\boldsymbol{w}, D)\;+\;\lambda\;||\;\boldsymbol{w}\;||\;_2^2
> $$
>

> 旨在减少训练误差L: 旨在减少训练误差 控制如何平衡权重的标量值λ: 控制如何平衡权重的标量值 平衡复杂度w: 平衡复杂度权重标准化的平方22: 权重标准化的L2平方

- 根据[奥卡姆剃刀定律](https://developers.google.com/machine-learning/crash-course/generalization/peril-of-overfitting#occam)，或许我们可以通过降低复杂模型的复杂度来防止过拟合，这种原则称为**正则化**。也就是说，并非只是以最小化损失（经验风险最小化）为目标：
  $$
  \text{minimize(Loss(Data|Model))}
  $$

- 而是以最小化损失和复杂度为目标，这称为**结构风险最小化**

- $$
  \text{minimize(Loss(Data|Model) + complexity(Model))}
  $$

- 现在，我们的训练优化算法是一个由两项内容组成的函数：一个是**损失项**，用于衡量模型与数据的拟合度，另一个是**正则化项**，用于衡量模型复杂度。

- 模型开发者通过以下方式来调整正则化项的整体影响：用正则化项的值乘以名为 **lambda**（又称为**正则化率**）的标量。也就是说，模型开发者会执行以下运算：

- $$
  \text{minimize(Loss(Data|Model)} + \lambda \text{ complexity(Model))}
  $$

  > 在选择 lambda 值时，目标是在简单化和训练数据拟合之间达到适当的平衡：
  >
  > - 如果您的 lambda 值过高，则模型会非常简单，但是您将面临数据欠拟合的风险。
  > - 如果您的 lambda 值过低，则模型会比较复杂，并且您将面临数据过拟合的风险。
  >
  > **注意**：将 lambda 设为 0 可彻底取消正则化。 在这种情况下，训练的唯一目的将是最小化损失，而这样做会使过拟合的风险达到最高。

## Logistic Regression

- **逻辑回归**会生成一个介于 0 到 1 之间（不包括 0 和 1）的概率值，而不是确切地预测结果是 0 还是 1。

- 线性模型：
  $$
  z=w^Tx+b
  $$

- sigmoid函数：

- $$
  y = \frac{1}{1 + e^{-z}}
  $$

  ​

- 将sigmoid函数和线性模型结合：

- $$
  y' = \frac{1}{1 + e^{-(w^Tx+b)}}
  $$

- 逻辑回归的损失函数

  > 线性回归的损失函数是平方损失。逻辑回归的损失函数是**对数损失函数**，定义如下：
  > $$
  > Log Loss = \sum_{(x,y)\in D} -ylog(y') - (1 - y)log(1 - y')
  > $$
  > 其中：
  >
  > - (*x,y*)ϵ*D* 是包含很多有标签样本 (*x*,*y*) 的数据集。
  > - y是有标签样本中的标签。**由于这是逻辑回归，因此“y”的每个值必须是 0 或 1。**
  > - y'是对于特征集“x”的预测值（介于 0 和 1 之间）。
  >
  > 对数损失函数的方程式与 [Shannon 信息论中的熵测量](https://wikipedia.org/wiki/Entropy_(information_theory))密切相关。它也是[似然函数](https://wikipedia.org/wiki/Likelihood_function)的负对数（假设“y”属于[伯努利分布](https://wikipedia.org/wiki/Bernoulli_distribution)）**。实际上，最大限度地降低损失函数的值会生成最大的似然估计值。

- 正则化对于逻辑回归而言至关重要。

- - 记住渐近线
  - 它会不断尝试促使**损失**在高维度空间内达到 0

- 以下两个策略尤其有用：

- - **L2 正则化**（也称为 L2 权重衰减）- 用于降低超大权重。
  - **早停法** - 用于限制训练步数或学习速率。

- 线性逻辑回归极其高效。

- - 超快的训练速度和较短的预测时间。
  - 短模型/宽度模型占用大量 RAM。

- 如果扩展到非线性逻辑回归，则可以通过使用特征组合实现

## Classification

- 阈值

- 选择合适的分类阈值：ROC 曲线**（**接收者操作特征曲线**）是一种显示分类模型在所有分类阈值下的效果的图表

  > ROC 曲线用于绘制采用不同分类阈值时的 TPR 与 FPR。降低分类阈值会导致将更多样本归为正类别，从而增加假正例和真正例的个数。
  >
  > ![roc](./tensorflow/image/roc.png)
  >
  > **曲线下面积**表示“ROC 曲线下面积”。也就是说，曲线下面积测量的是从 (0,0) 到 (1,1) 之间整个 ROC 曲线以下的整个二维面积（参考积分学）。

  ​

- 评估指标：

  - 准确率：正确预测所占比例；当您使用**分类不平衡的数据集**（比如正类别标签和负类别标签的数量之间存在明显差异）时，单单准确率一项并不能反映全面情况。这时候有两个能够更好地评估分类不平衡问题的指标：精确率和召回率。

  - $$
    \text{Accuracy} = \frac{TP+TN}{TP+TN+FP+FN}
    $$

  - $$
    \text{Precision} = \frac{TP}{TP+FP}
    $$

    $$
    \text{Recall} = \frac{TP}{TP+FN}
    $$

    > 要全面评估模型的有效性，必须**同时**检查精确率和召回率。遗憾的是，精确率和召回率往往是此消彼长的情况。也就是说，提高精确率通常会降低召回率值，反之亦然。
    >
    > **如果提高分类阈值**：假正例数量会减少，但假负例数量会相应地增加。结果，精确率有所提高，而召回率则有所降低

  - F1是精确率和召回率的调和平均值，在数值上偏向于较小的一边:

  - $$
    2*\frac{(precision*recall)}{(precision+recall)}
    $$

  - 对于分类不平衡问题，区分不同类型的错误会有所帮助

    > 我们做出以下定义：
    >
    > - “狼来了”是**正类别**。
    > - “没有狼”是**负类别**。
    >
    > 我们可以使用一个 2x2 [混淆矩阵](https://developers.google.com/machine-learning/crash-course/glossary#confusion_matrix)来总结我们的“狼预测”模型，该矩阵描述了所有可能出现的结果（共四种）：
    >
    > | **真正例 (TP)：**真实情况：受到狼的威胁。牧童说：“狼来了。”结果：牧童是个英雄。 | **假正例 (FP)：**真实情况：没受到狼的威胁。牧童说：“狼来了。”结果：村民们因牧童吵醒他们而感到非常生气。 |
    > | ---------------------------------------- | ---------------------------------------- |
    > | **假负例 (FN)：**真实情况：受到狼的威胁。牧童说：“没有狼”。结果：狼吃掉了所有的羊。 | **真负例 (TN)：**真实情况：没受到狼的威胁。牧童说：“没有狼”。结果：大家都没事。 |
    >
    > TP：true positive，实际是正例，预测为正例 
    > FP：false positive，实际为负例，预测为正例 
    > TN：true negative，实际为负例，预测为负例 
    > FN：false negative，实际为正例，预测为负例

  - **精确率**：（真正例次数）/（所有正类别预测次数）

  - **召回率**：（真正例次数）/（所有实际正类别数）

- 预测偏差

  - 逻辑回归预测应当无偏差。
  - - 预测平均值 == 观察平均值
  - 偏差是一个具有指示作用的值。
  - - 仅仅是零偏差并不能说明您系统中的一切都完美无缺。
    - 但偏差是一项非常实用的健全性检查项目。
  - 如果出现偏差，则说明存在问题。
  - - 特征集不完整？
    - 模型实现流水线中有错误？
    - 训练样本有偏差？
  - 请勿使用校准层来修正偏差，而应在模型中予以修正。
  - 查看各部分数据中是否存在偏差 - 这有助于指导如何进行改进。

## Regularization for Sparsity

- **注意**：稀疏特征组合可能会大大增加特征空间

- 可能出现的问题：

- 模型大小 (RAM) 可能会变得庞大

- “噪点”系数（导致过拟合）

  > - L0正则化： L0范数是指向量中非0的元素的个数，对非0权重进行惩罚
  >   - 非凸优化；NP 困难
  > - L1 正则化：L1范数是指向量中各个元素绝对值之和，降低**元素的绝对值**
  >
  >
  > - - 对绝对值（权重）之和进行惩罚
  >   - 凸优化问题
  >   - L1 鼓励稀疏性，会使得许多系数为零，L1范数会使权值稀疏
  >
  >
  > - 总结：L1范数和L0范数可以实现稀疏，L1因具有比L0更好的优化求解特性而被广泛应用。
  > - L2正则化： L2范数是指向量各元素的平方和然后求平方根，降低**元素平方和**
  > - 让L2范数的规则项||W||的平方最小，可以使得W的每个元素都很小，都接近于0，但与L1范数不同，它不会让它等于0，而是接近于0，越小的参数说明模型越简单，越简单的模型则越不容易产生过拟合现象。


- 稀疏矢量通常包含许多维度。创建[特征组合](https://developers.google.com/machine-learning/crash-course/feature-crosses/video-lecture)会导致包含更多维度。由于使用此类高维度特征矢量，因此模型可能会非常庞大，并且需要大量的 RAM。
- 在高维度稀疏矢量中，最好尽可能使权重正好降至 `0`。正好为 0 的权重基本上会使相应特征从模型中移除。 将特征设为 0 可节省 RAM 空间，且可以减少模型中的噪点。
- L2 正则化可以使权重变小，但是并不能使它们正好为 0.0;L0会将我们的凸优化问题变为非凸优化问题，即 [NP 困难](https://wikipedia.org/wiki/NP-hardness) ;L1 正则化这种正则化项的作用类似 L0，但它具有凸优化的优势，可有效进行计算。因此，我们可以使用 L1 正则化使模型中很多信息缺乏的系数正好为 0，降低模型大小，从而在推理时节省 RAM。

## Introduction to Neural Networks

- 什么是隐含层、什么事激活函数、常用的激活函数有什么？

- 神经网络能够很好的处理非线性复杂数据：音频、文字、视频、图片等

- 神经网络能够自动学习数据中存在的非线性规律，而不用手动指定参数

- **注意** ： 线性函数的组合依然是线性

- 常用的非线性函数：Sigmoid，ReLU(**修正线性单元**激活函数)

  >$$
  >F(x)=\frac{1} {1+e^{-x}}
  >$$
  >
  >$$
  >F(x)=max(0,x)
  >$$
  >

- 通用激活函数表示方式：
  $$
  \sigma(\boldsymbol w \cdot \boldsymbol x+b)
  $$

- 训练神经网络的方法是：反向传播（梯度下降的变形），通过反向传播，可以以合理高效的方式对非凸优化问题执行梯度下降。

- 激活函数所在层次，ReLU解析

- 总结

  - 人们通常所说的“神经网络”的所有标准组件：
    - 一组节点，类似于神经元，位于层中。
    - 一组权重，表示每个神经网络层与其下方的层之间的关系。下方的层可能是另一个神经网络层，也可能是其他类型的层。
    - 一组偏差，每个节点一个偏差。
    - 一个激活函数，对层中每个节点的输出进行转换。不同的层可能拥有不同的激活函数。

## Training Neural Networks

### 梯度消失

- 较低层（更接近输入）的梯度可能会变得非常小。在深度网络中，计算这些梯度时，可能涉及许多小项的乘积。
- 当较低层的梯度逐渐消失到 0 时，这些层的训练速度会非常缓慢，甚至不再训练。
- ReLU 激活函数有助于防止梯度消失。

### 梯度爆炸

- 如果网络中的权重过大，则较低层的梯度会涉及许多大项的乘积。在这种情况下，梯度就会爆炸：梯度过大导致难以收敛。
- 批标准化可以降低学习速率，因而有助于防止梯度爆炸。

### ReLU 单元消失

- 一旦 ReLU 单元的加权和低于 0，ReLU 单元就可能会停滞。它会输出对网络输出没有任何贡献的 0 激活，而梯度在反向传播算法期间将无法再从中流过。由于梯度的来源被切断，ReLU 的输入可能无法作出足够的改变来使加权和恢复到 0 以上。
- 降低学习速率有助于防止 ReLU 单元消失。

### 丢弃正则化

- 这是称为**丢弃**的另一种形式的正则化，可用于神经网络。其工作原理是，在梯度下降法的每一步中随机丢弃一些网络单元。丢弃得越多，正则化效果就越强：
  - 0.0 = 无丢弃正则化。
  - 1.0 = 丢弃所有内容。模型学不到任何规律。
  - 0.0 和 1.0 之间的值更有用。

## Multi-Class Neural Networks

> **一对多**提供了一种利用二元分类的方法。鉴于一个分类问题会有 N 个可行的解决方案，一对多解决方案包括 N 个单独的二元分类器，每个可能的结果对应一个二元分类器。在训练期间，模型会训练一系列二元分类器，使每个分类器都能回答单独的分类问题。以一张狗狗的照片为例，可能需要训练五个不同的识别器，其中四个将图片看作负样本（不是狗狗），一个将图片看作正样本（是狗狗）。即：
>
> 1. 这是一张苹果的图片吗？不是。
> 2. 这是一张熊的图片吗？不是。
> 3. 这是一张糖果的图片吗？不是。
> 4. 这是一张狗狗的图片吗？是。
> 5. 这是一张鸡蛋的图片吗？不是。
>
> 当类别总数较少时，这种方法比较合理，但随着类别数量的增加，其效率会变得越来越低下。可以借助深度神经网络（在该网络中，每个输出节点表示一个不同的类别）创建明显更加高效的一对多模型。

- 已经知道，[逻辑回归](https://developers.google.com/machine-learning/crash-course/logistic-regression)可生成介于 0 和 1.0 之间的小数。例如，某电子邮件分类器的逻辑回归输出值为 0.8，表明电子邮件是垃圾邮件的概率为 80%，不是垃圾邮件的概率为 20%。很明显，一封电子邮件是垃圾邮件或非垃圾邮件的概率之和为 1.0。

- **Softmax** 将这一想法延伸到多类别领域。也就是说，在多类别问题中，Softmax 会为每个类别分配一个用小数表示的概率。这些用小数表示的概率相加之和必须是 1.0。与其他方式相比，这种附加限制有助于让训练过程更快速地收敛。

- Softmax 层是紧挨着输出层之前的神经网络层。Softmax 层必须和输出层拥有一样的节点数。

- Softmax 方程式如下所示：
  $$
  p(y=j|x)=e(wjTx+bj)∑k∈Ke(wkTx+bk)
  $$
  请注意，此公式本质上是将逻辑回归公式延伸到了多类别。

- 一个标签与多个标签

  > Softmax 假设每个样本只是一个类别的成员。但是，一些样本可以同时是多个类别的成员。对于此类示例：
  >
  > - 您不能使用 Softmax。
  > - 您必须依赖多个逻辑回归。
  >
  > 例如，假设您的样本是只包含一项内容（一块水果）的图片。Softmax 可以确定该内容是梨、橙子、苹果等的概率。如果您的样本是包含各种各样内容（几碗不同种类的水果）的图片，您必须改用多个逻辑回归

## Embedding

- 嵌入是一种相对低维的空间，您可以将高维矢量映射到这种低维空间里。通过使用嵌入，可以让在大型输入（比如代表字词的稀疏矢量）上进行机器学习变得更加容易。

- 在理想情况下，嵌套可以将语义上相似的不同输入映射到嵌套空间里的邻近处

- 一个模型学习到的嵌入，也可以被其他模型重用。

- 将大型稀疏矢量映射到一个保留语义关系的低维空间

- 要解决稀疏输入数据的核心问题，您可以将高维度数据映射到低维度空间。

  即便是小型多维空间，也能自由地将语义上相似的项归到一起，并将相异项分开。矢量空间中的位置（距离和方向）可对良好的嵌套中的语义进行编码。例如，下面的真实嵌套可视化图所展示的几何关系图捕获了国家与其首都之间的语义关系。

![embedding.png](tensorflow/image/embedding.png)

- 收缩网络

  尽管我们需要足够的维度来编码丰富的语义关系，但我们也需要足够小的嵌套空间来更快速地训练我们的系统。实用嵌套的量级大致有数百个维度。这可能比您在自然语言任务中使用的词汇规模要小好几个数量级。

- 嵌套充当    查询表

  嵌套是一个矩阵，每列表示您词汇中的一项所对应的矢量。要获得某个词汇项的密集矢量，您可以检索该项所对应的列。

- 嵌套查询充当   矩阵乘法

  我们刚刚阐述的查询、乘法和加法程序等效于矩阵乘法。假设有一个 1 X N 的稀疏表示 S 和一个 N X M 的嵌套表 E，矩阵乘法 S X E 可以得出密集矢量 1 X M。

- 获取嵌套

  - 标准降维技术 eg:[主成分分析](https://wikipedia.org/wiki/Principal_component_analysis) (PCA) 已用于创建字词嵌套。在给定一组实例的情况下，例如字词矢量包，PCA 会尝试查找高度相关且可以合并的维度。
  - Word2vec  Word2vec 是 Google 为了训练字词嵌套而研发的一种算法。Word2vec 基于**分布假设**，将语义上相似的字词映射到在几何图形上邻近的嵌套矢量。

## Production ML Systems

- Static vs. Dynamic Training

- 从广义上讲，训练模型的方式有两种：

  - **静态模型**采用**离线训练**方式。也就是说，我们只训练模型一次，然后使用训练后的模型一段时间。
  - **动态模型**采用**在线训练**方式。也就是说，数据会不断进入系统，我们通过不断地更新系统将这些数据整合到模型中。

  > 静态模型 - 离线训练
  >
  > - 易于构建和测试 - 使用批量训练和测试，对其进行迭代，直到达到良好效果。
  > - 仍然需要对输入进行监控
  > - 模型容易过时
  >
  > 动态模型 - 在线训练
  >
  > - 随着时间推移不断为训练数据注入新数据，定期同步更新版本。
  > - 使用渐进式验证，而不是批量训练和测试
  > - 需要监控、模型回滚和数据隔离功能
  > - 会根据变化作出相应调整，避免了过时问题

  - **离线推理**（预测），指的是使用 MapReduce 或类似方法批量进行所有可能的预测。然后，将预测记录到 SSTable 或 Bigtable 中，并将它们提供给一个缓存/查询表。
  - **在线推理**（预测），指的是使用服务器根据需要进行预测。

## ML Systems in the Real World

- **癌症预测应用**：存在**标签泄露**的问题：即一些训练标签泄露到特征中，使得模型带有欺骗性。
- **18 世纪文学**表明：在随机化拆分数据集的时候，需要准确全面的了解到数据代表的含义，才能更好的拆分数据
- 一些有效的机器学习准则
  - 确保第一个模型简单易用
  - 着重确保数据管道的正确性
  - 使用简单且可观察的指标进行训练和评估
  - 拥有并监控您的输入特征
  - 将您的模型配置视为代码：进行审核并记录在案
  - 记下所有实验的结果，尤其是“失败”的结果